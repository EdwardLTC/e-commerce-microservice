// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v6.32.1
// source: Order.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { handleUnaryCall, UntypedServiceImplementation } from "@grpc/grpc-js";
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { Observable } from "rxjs";
import { Empty } from "./google/protobuf/empty";
import { Timestamp } from "./google/protobuf/timestamp";

export const protobufPackage = "com.ecommerce.golang.order";

export enum OrderStatus {
  ORDER_STATUS_DRAFT_UNSPECIFIED = 0,
  ORDER_STATUS_PENDING_PAYMENT = 1,
  ORDER_STATUS_PAYMENT_RECEIVED = 2,
  ORDER_STATUS_PROCESSING = 3,
  ORDER_STATUS_SHIPPED = 4,
  ORDER_STATUS_DELIVERED = 5,
  ORDER_STATUS_CANCELLED = 6,
  ORDER_STATUS_ON_HOLD = 7,
  ORDER_STATUS_REFUNDED = 8,
  UNRECOGNIZED = -1,
}

export enum RefundStatus {
  REFUND_STATUS_REQUESTED_UNSPECIFIED = 0,
  REFUND_STATUS_APPROVED = 1,
  REFUND_STATUS_REJECTED = 2,
  REFUND_STATUS_PROCESSED = 3,
  REFUND_STATUS_FAILED = 4,
  UNRECOGNIZED = -1,
}

export enum PaymentMethod {
  PAYMENT_METHOD_UNSPECIFIED = 0,
  PAYMENT_METHOD_CREDIT_CARD = 1,
  PAYMENT_METHOD_PAYPAL = 2,
  PAYMENT_METHOD_BANK_TRANSFER = 3,
  PAYMENT_METHOD_CRYPTO = 4,
  PAYMENT_METHOD_CASH = 5,
  UNRECOGNIZED = -1,
}

export interface Order {
  /** UUID */
  id: string;
  /** UUID */
  customerId: string;
  status: OrderStatus;
  subtotal: number;
  tax: number;
  shippingCost: number;
  total: number;
  shippingAddress: string;
  billingAddress: string;
  /** UUID */
  paymentIntentId: string;
  createdAt?: Timestamp | undefined;
  updatedAt?: Timestamp | undefined;
  items: OrderItem[];
  refunds: Refund[];
}

export interface OrderItem {
  /** UUID */
  id: string;
  /** UUID */
  productId: string;
  /** UUID */
  variantId: string;
  productName: string;
  variantDescription: string;
  unitPrice: number;
  salePrice: number;
  quantity: number;
  totalPrice: number;
  imageUrl: string;
  createdAt?: Timestamp | undefined;
  updatedAt?: Timestamp | undefined;
}

export interface Refund {
  /** UUID */
  id: string;
  status: RefundStatus;
  amount: number;
  reason: string;
  /** UUID */
  paymentRefundId: string;
  /** UUIDs */
  orderItemIds: string[];
  createdAt?: Timestamp | undefined;
  updatedAt?: Timestamp | undefined;
}

export interface CreateOrderResponse {
  id: string;
  status: OrderStatus;
  paymentUrl: string;
}

/** Order Management */
export interface CreateOrderRequest {
  /** UUID */
  customerId: string;
  items: OrderItemRequest[];
  shippingAddress: string;
  /** string idempotencyKey = 5; // UUID */
  billingAddress: string;
}

export interface OrderItemRequest {
  /** UUID */
  variantId: string;
  quantity: number;
}

export interface GetOrderRequest {
  /** UUID */
  id: string;
}

export interface UpdateOrderStatusRequest {
  /** UUID */
  id: string;
  status: OrderStatus;
}

export interface ListOrdersRequest {
  page: number;
  pageSize: number;
  /** Optional filter */
  customerId: string;
  /** Optional filter */
  status: OrderStatus;
  createdAfter?: Timestamp | undefined;
}

export interface ListOrdersResponse {
  orders: Order[];
  totalCount: number;
  currentPage: number;
  totalPages: number;
}

/** Payment Integration */
export interface PaymentIntentRequest {
  /** UUID */
  orderId: string;
  amount: number;
  /** ISO 4217 */
  currency: string;
  method: PaymentMethod;
  customerEmail: string;
  metadata: { [key: string]: string };
}

export interface PaymentIntentRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface PaymentIntentResponse {
  /** UUID */
  paymentIntentId: string;
  /** For Stripe-like integrations */
  clientSecret: string;
  redirectUrl: string;
}

export interface PaymentWebhookRequest {
  eventId: string;
  eventType: string;
  /** UUID */
  paymentIntentId: string;
  amount: number;
  currency: string;
  success: boolean;
  createdAt?: Timestamp | undefined;
  metadata: { [key: string]: string };
  /** For verification */
  signature: string;
}

export interface PaymentWebhookRequest_MetadataEntry {
  key: string;
  value: string;
}

/** Refunds */
export interface CreateRefundRequest {
  /** UUID */
  orderId: string;
  /** UUIDs */
  orderItemIds: string[];
  reason: string;
  amount: number;
}

export interface ProcessRefundRequest {
  /** UUID */
  refundId: string;
  /** UUID from payment service */
  paymentRefundId: string;
}

export const COM_ECOMMERCE_GOLANG_ORDER_PACKAGE_NAME = "com.ecommerce.golang.order";

function createBaseOrder(): Order {
  return {
    id: "",
    customerId: "",
    status: 0,
    subtotal: 0,
    tax: 0,
    shippingCost: 0,
    total: 0,
    shippingAddress: "",
    billingAddress: "",
    paymentIntentId: "",
    items: [],
    refunds: [],
  };
}

export const Order: MessageFns<Order> = {
  encode(message: Order, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.customerId !== "") {
      writer.uint32(18).string(message.customerId);
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    if (message.subtotal !== 0) {
      writer.uint32(33).double(message.subtotal);
    }
    if (message.tax !== 0) {
      writer.uint32(41).double(message.tax);
    }
    if (message.shippingCost !== 0) {
      writer.uint32(49).double(message.shippingCost);
    }
    if (message.total !== 0) {
      writer.uint32(57).double(message.total);
    }
    if (message.shippingAddress !== "") {
      writer.uint32(66).string(message.shippingAddress);
    }
    if (message.billingAddress !== "") {
      writer.uint32(74).string(message.billingAddress);
    }
    if (message.paymentIntentId !== "") {
      writer.uint32(82).string(message.paymentIntentId);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(90).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(98).fork()).join();
    }
    for (const v of message.items) {
      OrderItem.encode(v!, writer.uint32(106).fork()).join();
    }
    for (const v of message.refunds) {
      Refund.encode(v!, writer.uint32(114).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Order {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.customerId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.subtotal = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.tax = reader.double();
          continue;
        }
        case 6: {
          if (tag !== 49) {
            break;
          }

          message.shippingCost = reader.double();
          continue;
        }
        case 7: {
          if (tag !== 57) {
            break;
          }

          message.total = reader.double();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.shippingAddress = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.billingAddress = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.paymentIntentId = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.items.push(OrderItem.decode(reader, reader.uint32()));
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.refunds.push(Refund.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseOrderItem(): OrderItem {
  return {
    id: "",
    productId: "",
    variantId: "",
    productName: "",
    variantDescription: "",
    unitPrice: 0,
    salePrice: 0,
    quantity: 0,
    totalPrice: 0,
    imageUrl: "",
  };
}

export const OrderItem: MessageFns<OrderItem> = {
  encode(message: OrderItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.productId !== "") {
      writer.uint32(18).string(message.productId);
    }
    if (message.variantId !== "") {
      writer.uint32(26).string(message.variantId);
    }
    if (message.productName !== "") {
      writer.uint32(34).string(message.productName);
    }
    if (message.variantDescription !== "") {
      writer.uint32(42).string(message.variantDescription);
    }
    if (message.unitPrice !== 0) {
      writer.uint32(49).double(message.unitPrice);
    }
    if (message.salePrice !== 0) {
      writer.uint32(57).double(message.salePrice);
    }
    if (message.quantity !== 0) {
      writer.uint32(64).int32(message.quantity);
    }
    if (message.totalPrice !== 0) {
      writer.uint32(73).double(message.totalPrice);
    }
    if (message.imageUrl !== "") {
      writer.uint32(82).string(message.imageUrl);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(90).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.variantId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.productName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.variantDescription = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 49) {
            break;
          }

          message.unitPrice = reader.double();
          continue;
        }
        case 7: {
          if (tag !== 57) {
            break;
          }

          message.salePrice = reader.double();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.quantity = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 73) {
            break;
          }

          message.totalPrice = reader.double();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.imageUrl = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRefund(): Refund {
  return { id: "", status: 0, amount: 0, reason: "", paymentRefundId: "", orderItemIds: [] };
}

export const Refund: MessageFns<Refund> = {
  encode(message: Refund, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.amount !== 0) {
      writer.uint32(25).double(message.amount);
    }
    if (message.reason !== "") {
      writer.uint32(34).string(message.reason);
    }
    if (message.paymentRefundId !== "") {
      writer.uint32(42).string(message.paymentRefundId);
    }
    for (const v of message.orderItemIds) {
      writer.uint32(50).string(v!);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(58).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Refund {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefund();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.amount = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.paymentRefundId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.orderItemIds.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateOrderResponse(): CreateOrderResponse {
  return { id: "", status: 0, paymentUrl: "" };
}

export const CreateOrderResponse: MessageFns<CreateOrderResponse> = {
  encode(message: CreateOrderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.paymentUrl !== "") {
      writer.uint32(26).string(message.paymentUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateOrderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.paymentUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateOrderRequest(): CreateOrderRequest {
  return { customerId: "", items: [], shippingAddress: "", billingAddress: "" };
}

export const CreateOrderRequest: MessageFns<CreateOrderRequest> = {
  encode(message: CreateOrderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customerId !== "") {
      writer.uint32(10).string(message.customerId);
    }
    for (const v of message.items) {
      OrderItemRequest.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.shippingAddress !== "") {
      writer.uint32(26).string(message.shippingAddress);
    }
    if (message.billingAddress !== "") {
      writer.uint32(34).string(message.billingAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateOrderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.customerId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.items.push(OrderItemRequest.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.shippingAddress = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.billingAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseOrderItemRequest(): OrderItemRequest {
  return { variantId: "", quantity: 0 };
}

export const OrderItemRequest: MessageFns<OrderItemRequest> = {
  encode(message: OrderItemRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.variantId !== "") {
      writer.uint32(18).string(message.variantId);
    }
    if (message.quantity !== 0) {
      writer.uint32(24).int32(message.quantity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderItemRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderItemRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.variantId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.quantity = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetOrderRequest(): GetOrderRequest {
  return { id: "" };
}

export const GetOrderRequest: MessageFns<GetOrderRequest> = {
  encode(message: GetOrderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOrderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateOrderStatusRequest(): UpdateOrderStatusRequest {
  return { id: "", status: 0 };
}

export const UpdateOrderStatusRequest: MessageFns<UpdateOrderStatusRequest> = {
  encode(message: UpdateOrderStatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateOrderStatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateOrderStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListOrdersRequest(): ListOrdersRequest {
  return { page: 0, pageSize: 0, customerId: "", status: 0 };
}

export const ListOrdersRequest: MessageFns<ListOrdersRequest> = {
  encode(message: ListOrdersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.page !== 0) {
      writer.uint32(8).int32(message.page);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.customerId !== "") {
      writer.uint32(26).string(message.customerId);
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    if (message.createdAfter !== undefined) {
      Timestamp.encode(message.createdAfter, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListOrdersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOrdersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.customerId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createdAfter = Timestamp.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListOrdersResponse(): ListOrdersResponse {
  return { orders: [], totalCount: 0, currentPage: 0, totalPages: 0 };
}

export const ListOrdersResponse: MessageFns<ListOrdersResponse> = {
  encode(message: ListOrdersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.orders) {
      Order.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalCount !== 0) {
      writer.uint32(16).int32(message.totalCount);
    }
    if (message.currentPage !== 0) {
      writer.uint32(24).int32(message.currentPage);
    }
    if (message.totalPages !== 0) {
      writer.uint32(32).int32(message.totalPages);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListOrdersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOrdersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orders.push(Order.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.currentPage = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalPages = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePaymentIntentRequest(): PaymentIntentRequest {
  return { orderId: "", amount: 0, currency: "", method: 0, customerEmail: "", metadata: {} };
}

export const PaymentIntentRequest: MessageFns<PaymentIntentRequest> = {
  encode(message: PaymentIntentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    if (message.amount !== 0) {
      writer.uint32(17).double(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(26).string(message.currency);
    }
    if (message.method !== 0) {
      writer.uint32(32).int32(message.method);
    }
    if (message.customerEmail !== "") {
      writer.uint32(42).string(message.customerEmail);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      PaymentIntentRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentIntentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentIntentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.amount = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.method = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.customerEmail = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          const entry6 = PaymentIntentRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.metadata[entry6.key] = entry6.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePaymentIntentRequest_MetadataEntry(): PaymentIntentRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const PaymentIntentRequest_MetadataEntry: MessageFns<PaymentIntentRequest_MetadataEntry> = {
  encode(message: PaymentIntentRequest_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentIntentRequest_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentIntentRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePaymentIntentResponse(): PaymentIntentResponse {
  return { paymentIntentId: "", clientSecret: "", redirectUrl: "" };
}

export const PaymentIntentResponse: MessageFns<PaymentIntentResponse> = {
  encode(message: PaymentIntentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paymentIntentId !== "") {
      writer.uint32(10).string(message.paymentIntentId);
    }
    if (message.clientSecret !== "") {
      writer.uint32(18).string(message.clientSecret);
    }
    if (message.redirectUrl !== "") {
      writer.uint32(26).string(message.redirectUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentIntentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentIntentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paymentIntentId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientSecret = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.redirectUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePaymentWebhookRequest(): PaymentWebhookRequest {
  return {
    eventId: "",
    eventType: "",
    paymentIntentId: "",
    amount: 0,
    currency: "",
    success: false,
    metadata: {},
    signature: "",
  };
}

export const PaymentWebhookRequest: MessageFns<PaymentWebhookRequest> = {
  encode(message: PaymentWebhookRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventId !== "") {
      writer.uint32(10).string(message.eventId);
    }
    if (message.eventType !== "") {
      writer.uint32(18).string(message.eventType);
    }
    if (message.paymentIntentId !== "") {
      writer.uint32(26).string(message.paymentIntentId);
    }
    if (message.amount !== 0) {
      writer.uint32(33).double(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(42).string(message.currency);
    }
    if (message.success !== false) {
      writer.uint32(48).bool(message.success);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(58).fork()).join();
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      PaymentWebhookRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).join();
    });
    if (message.signature !== "") {
      writer.uint32(74).string(message.signature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentWebhookRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentWebhookRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.eventType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.paymentIntentId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.amount = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          const entry8 = PaymentWebhookRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.metadata[entry8.key] = entry8.value;
          }
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.signature = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePaymentWebhookRequest_MetadataEntry(): PaymentWebhookRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const PaymentWebhookRequest_MetadataEntry: MessageFns<PaymentWebhookRequest_MetadataEntry> = {
  encode(message: PaymentWebhookRequest_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentWebhookRequest_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentWebhookRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateRefundRequest(): CreateRefundRequest {
  return { orderId: "", orderItemIds: [], reason: "", amount: 0 };
}

export const CreateRefundRequest: MessageFns<CreateRefundRequest> = {
  encode(message: CreateRefundRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    for (const v of message.orderItemIds) {
      writer.uint32(18).string(v!);
    }
    if (message.reason !== "") {
      writer.uint32(26).string(message.reason);
    }
    if (message.amount !== 0) {
      writer.uint32(33).double(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateRefundRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateRefundRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.orderItemIds.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.amount = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseProcessRefundRequest(): ProcessRefundRequest {
  return { refundId: "", paymentRefundId: "" };
}

export const ProcessRefundRequest: MessageFns<ProcessRefundRequest> = {
  encode(message: ProcessRefundRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.refundId !== "") {
      writer.uint32(10).string(message.refundId);
    }
    if (message.paymentRefundId !== "") {
      writer.uint32(18).string(message.paymentRefundId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessRefundRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessRefundRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.refundId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.paymentRefundId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

export interface OrderServiceClient {
  /** Order Management */

  createOrder(request: CreateOrderRequest): Observable<CreateOrderResponse>;

  getOrder(request: GetOrderRequest): Observable<Order>;

  updateOrderStatus(request: UpdateOrderStatusRequest): Observable<Order>;

  listOrders(request: ListOrdersRequest): Observable<ListOrdersResponse>;

  /** Payment Integration */

  initiatePayment(request: PaymentIntentRequest): Observable<PaymentIntentResponse>;

  handlePaymentWebhook(request: PaymentWebhookRequest): Observable<Empty>;

  /** Refunds */

  createRefund(request: CreateRefundRequest): Observable<Refund>;

  processRefund(request: ProcessRefundRequest): Observable<Refund>;
}

export interface OrderServiceController {
  /** Order Management */

  createOrder(
    request: CreateOrderRequest,
  ): Promise<CreateOrderResponse> | Observable<CreateOrderResponse> | CreateOrderResponse;

  getOrder(request: GetOrderRequest): Promise<Order> | Observable<Order> | Order;

  updateOrderStatus(request: UpdateOrderStatusRequest): Promise<Order> | Observable<Order> | Order;

  listOrders(
    request: ListOrdersRequest,
  ): Promise<ListOrdersResponse> | Observable<ListOrdersResponse> | ListOrdersResponse;

  /** Payment Integration */

  initiatePayment(
    request: PaymentIntentRequest,
  ): Promise<PaymentIntentResponse> | Observable<PaymentIntentResponse> | PaymentIntentResponse;

  handlePaymentWebhook(request: PaymentWebhookRequest): void;

  /** Refunds */

  createRefund(request: CreateRefundRequest): Promise<Refund> | Observable<Refund> | Refund;

  processRefund(request: ProcessRefundRequest): Promise<Refund> | Observable<Refund> | Refund;
}

export function OrderServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = [
      "createOrder",
      "getOrder",
      "updateOrderStatus",
      "listOrders",
      "initiatePayment",
      "handlePaymentWebhook",
      "createRefund",
      "processRefund",
    ];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("OrderService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("OrderService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const ORDER_SERVICE_NAME = "OrderService";

export type OrderServiceService = typeof OrderServiceService;
export const OrderServiceService = {
  /** Order Management */
  createOrder: {
    path: "/com.ecommerce.golang.order.OrderService/CreateOrder",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateOrderRequest): Buffer => Buffer.from(CreateOrderRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateOrderRequest => CreateOrderRequest.decode(value),
    responseSerialize: (value: CreateOrderResponse): Buffer => Buffer.from(CreateOrderResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CreateOrderResponse => CreateOrderResponse.decode(value),
  },
  getOrder: {
    path: "/com.ecommerce.golang.order.OrderService/GetOrder",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetOrderRequest): Buffer => Buffer.from(GetOrderRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetOrderRequest => GetOrderRequest.decode(value),
    responseSerialize: (value: Order): Buffer => Buffer.from(Order.encode(value).finish()),
    responseDeserialize: (value: Buffer): Order => Order.decode(value),
  },
  updateOrderStatus: {
    path: "/com.ecommerce.golang.order.OrderService/UpdateOrderStatus",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateOrderStatusRequest): Buffer =>
      Buffer.from(UpdateOrderStatusRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateOrderStatusRequest => UpdateOrderStatusRequest.decode(value),
    responseSerialize: (value: Order): Buffer => Buffer.from(Order.encode(value).finish()),
    responseDeserialize: (value: Buffer): Order => Order.decode(value),
  },
  listOrders: {
    path: "/com.ecommerce.golang.order.OrderService/ListOrders",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListOrdersRequest): Buffer => Buffer.from(ListOrdersRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListOrdersRequest => ListOrdersRequest.decode(value),
    responseSerialize: (value: ListOrdersResponse): Buffer => Buffer.from(ListOrdersResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListOrdersResponse => ListOrdersResponse.decode(value),
  },
  /** Payment Integration */
  initiatePayment: {
    path: "/com.ecommerce.golang.order.OrderService/InitiatePayment",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PaymentIntentRequest): Buffer => Buffer.from(PaymentIntentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PaymentIntentRequest => PaymentIntentRequest.decode(value),
    responseSerialize: (value: PaymentIntentResponse): Buffer =>
      Buffer.from(PaymentIntentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PaymentIntentResponse => PaymentIntentResponse.decode(value),
  },
  handlePaymentWebhook: {
    path: "/com.ecommerce.golang.order.OrderService/HandlePaymentWebhook",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PaymentWebhookRequest): Buffer =>
      Buffer.from(PaymentWebhookRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PaymentWebhookRequest => PaymentWebhookRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  /** Refunds */
  createRefund: {
    path: "/com.ecommerce.golang.order.OrderService/CreateRefund",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateRefundRequest): Buffer => Buffer.from(CreateRefundRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateRefundRequest => CreateRefundRequest.decode(value),
    responseSerialize: (value: Refund): Buffer => Buffer.from(Refund.encode(value).finish()),
    responseDeserialize: (value: Buffer): Refund => Refund.decode(value),
  },
  processRefund: {
    path: "/com.ecommerce.golang.order.OrderService/ProcessRefund",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ProcessRefundRequest): Buffer => Buffer.from(ProcessRefundRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ProcessRefundRequest => ProcessRefundRequest.decode(value),
    responseSerialize: (value: Refund): Buffer => Buffer.from(Refund.encode(value).finish()),
    responseDeserialize: (value: Buffer): Refund => Refund.decode(value),
  },
} as const;

export interface OrderServiceServer extends UntypedServiceImplementation {
  /** Order Management */
  createOrder: handleUnaryCall<CreateOrderRequest, CreateOrderResponse>;
  getOrder: handleUnaryCall<GetOrderRequest, Order>;
  updateOrderStatus: handleUnaryCall<UpdateOrderStatusRequest, Order>;
  listOrders: handleUnaryCall<ListOrdersRequest, ListOrdersResponse>;
  /** Payment Integration */
  initiatePayment: handleUnaryCall<PaymentIntentRequest, PaymentIntentResponse>;
  handlePaymentWebhook: handleUnaryCall<PaymentWebhookRequest, Empty>;
  /** Refunds */
  createRefund: handleUnaryCall<CreateRefundRequest, Refund>;
  processRefund: handleUnaryCall<ProcessRefundRequest, Refund>;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
}
