// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v6.32.1
// source: Product.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { handleUnaryCall, UntypedServiceImplementation } from "@grpc/grpc-js";
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { Observable } from "rxjs";
import { DoubleValue, Int32Value, StringValue } from "./google/protobuf/wrappers";

export const protobufPackage = "com.ecommerce.springboot.product.v1";

/**
 * ==========================
 * Product Messages
 * ==========================
 */
export interface GetProductsRequest {
  skip?: number | undefined;
  take?: number | undefined;
}

export interface GetProductsResponse {
  products: Product[];
}

export interface GetProductDetailRequest {
  id?: string | undefined;
}

export interface GetProductDetailResponse {
  id: string;
  name: string;
  description: string;
  brand: string;
  totalSaleCount: number;
  averageRating: number;
  mediaUrls: string[];
  optionTypes: OptionType[];
  variants: Variant[];
}

export interface CreateProductRequest {
  name?: string | undefined;
  sellerId?: string | undefined;
  description?: string | undefined;
  brand?: string | undefined;
  mediaUrls: string[];
}

export interface CreateProductResponse {
  id: string;
}

/**
 * ==========================
 * Option Messages
 * ==========================
 */
export interface CreateOptionTypeRequest {
  productId?: string | undefined;
  name?: string | undefined;
  displayOrder?: number | undefined;
}

export interface CreateOptionTypeResponse {
  id: string;
}

export interface GetOptionTypesRequest {
  productId?: string | undefined;
}

export interface GetOptionTypesResponse {
  optionTypes: OptionType[];
}

export interface CreateOptionValueRequest {
  optionTypeId?: string | undefined;
  value?: string | undefined;
  mediaUrl?: string | undefined;
  displayOrder?: number | undefined;
}

export interface CreateOptionValueResponse {
  id: string;
}

export interface GetOptionValuesRequest {
  optionTypeId?: string | undefined;
}

export interface GetOptionValuesResponse {
  optionValues: OptionValue[];
}

/**
 * ==========================
 * Variant Messages
 * ==========================
 */
export interface CreateVariantRequest {
  productId?: string | undefined;
  sku?: string | undefined;
  price?: number | undefined;
  stock?: number | undefined;
  mediaUrl?: string | undefined;
  options: string[];
}

export interface CreateVariantResponse {
  id: string;
}

export interface ReserveStockRequest {
  items: VariantItem[];
}

export interface ReserveStockResponse {
  reservationId: string;
  variants: ReserveStockResponse_VariantWithProduct[];
}

export interface ReserveStockResponse_VariantWithProduct {
  id: string;
  sku: string;
  price: number;
  salePrice: number;
  stock: number;
  mediaUrl: string;
  productId: string;
  productName: string;
}

export interface ReleaseStockRequest {
  reservationId: string;
}

export interface VariantItem {
  variantId: string;
  quantity: number;
}

/**
 * ==========================
 * Domain Models
 * ==========================
 */
export interface Product {
  id: string;
  name: string;
  description: string;
  brand: string;
  minPrice: number;
  maxPrice: number;
  totalSaleCount: number;
  rating: number;
  mediaUrls: string[];
}

export interface OptionType {
  id: string;
  name: string;
  displayOrder: number;
  optionValues: OptionValue[];
}

export interface OptionValue {
  id: string;
  value: string;
  mediaUrl: string;
  displayOrder: number;
}

export interface Variant {
  id: string;
  sku: string;
  price: number;
  salePrice: number;
  stock: number;
  status: string;
  mediaUrl: string;
  selectedOptions: SelectedOption[];
}

export interface SelectedOption {
  optionTypeId: string;
  optionValueId: string;
}

export const COM_ECOMMERCE_SPRINGBOOT_PRODUCT_V1_PACKAGE_NAME = "com.ecommerce.springboot.product.v1";

function createBaseGetProductsRequest(): GetProductsRequest {
  return {};
}

export const GetProductsRequest: MessageFns<GetProductsRequest> = {
  encode(message: GetProductsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.skip !== undefined) {
      Int32Value.encode({ value: message.skip! }, writer.uint32(10).fork()).join();
    }
    if (message.take !== undefined) {
      Int32Value.encode({ value: message.take! }, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProductsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProductsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.skip = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.take = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetProductsResponse(): GetProductsResponse {
  return { products: [] };
}

export const GetProductsResponse: MessageFns<GetProductsResponse> = {
  encode(message: GetProductsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.products) {
      Product.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProductsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProductsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.products.push(Product.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetProductDetailRequest(): GetProductDetailRequest {
  return {};
}

export const GetProductDetailRequest: MessageFns<GetProductDetailRequest> = {
  encode(message: GetProductDetailRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      StringValue.encode({ value: message.id! }, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProductDetailRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProductDetailRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = StringValue.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetProductDetailResponse(): GetProductDetailResponse {
  return {
    id: "",
    name: "",
    description: "",
    brand: "",
    totalSaleCount: 0,
    averageRating: 0,
    mediaUrls: [],
    optionTypes: [],
    variants: [],
  };
}

export const GetProductDetailResponse: MessageFns<GetProductDetailResponse> = {
  encode(message: GetProductDetailResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.brand !== "") {
      writer.uint32(34).string(message.brand);
    }
    if (message.totalSaleCount !== 0) {
      writer.uint32(40).int32(message.totalSaleCount);
    }
    if (message.averageRating !== 0) {
      writer.uint32(49).double(message.averageRating);
    }
    for (const v of message.mediaUrls) {
      writer.uint32(58).string(v!);
    }
    for (const v of message.optionTypes) {
      OptionType.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.variants) {
      Variant.encode(v!, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProductDetailResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProductDetailResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.brand = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.totalSaleCount = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 49) {
            break;
          }

          message.averageRating = reader.double();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.mediaUrls.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.optionTypes.push(OptionType.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.variants.push(Variant.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateProductRequest(): CreateProductRequest {
  return { mediaUrls: [] };
}

export const CreateProductRequest: MessageFns<CreateProductRequest> = {
  encode(message: CreateProductRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined) {
      StringValue.encode({ value: message.name! }, writer.uint32(10).fork()).join();
    }
    if (message.sellerId !== undefined) {
      StringValue.encode({ value: message.sellerId! }, writer.uint32(18).fork()).join();
    }
    if (message.description !== undefined) {
      StringValue.encode({ value: message.description! }, writer.uint32(26).fork()).join();
    }
    if (message.brand !== undefined) {
      StringValue.encode({ value: message.brand! }, writer.uint32(34).fork()).join();
    }
    for (const v of message.mediaUrls) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateProductRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateProductRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = StringValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sellerId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = StringValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.brand = StringValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.mediaUrls.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateProductResponse(): CreateProductResponse {
  return { id: "" };
}

export const CreateProductResponse: MessageFns<CreateProductResponse> = {
  encode(message: CreateProductResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateProductResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateProductResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateOptionTypeRequest(): CreateOptionTypeRequest {
  return {};
}

export const CreateOptionTypeRequest: MessageFns<CreateOptionTypeRequest> = {
  encode(message: CreateOptionTypeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.productId !== undefined) {
      StringValue.encode({ value: message.productId! }, writer.uint32(10).fork()).join();
    }
    if (message.name !== undefined) {
      StringValue.encode({ value: message.name! }, writer.uint32(18).fork()).join();
    }
    if (message.displayOrder !== undefined) {
      Int32Value.encode({ value: message.displayOrder! }, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateOptionTypeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOptionTypeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.productId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = StringValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.displayOrder = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateOptionTypeResponse(): CreateOptionTypeResponse {
  return { id: "" };
}

export const CreateOptionTypeResponse: MessageFns<CreateOptionTypeResponse> = {
  encode(message: CreateOptionTypeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateOptionTypeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOptionTypeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetOptionTypesRequest(): GetOptionTypesRequest {
  return {};
}

export const GetOptionTypesRequest: MessageFns<GetOptionTypesRequest> = {
  encode(message: GetOptionTypesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.productId !== undefined) {
      StringValue.encode({ value: message.productId! }, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOptionTypesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOptionTypesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.productId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetOptionTypesResponse(): GetOptionTypesResponse {
  return { optionTypes: [] };
}

export const GetOptionTypesResponse: MessageFns<GetOptionTypesResponse> = {
  encode(message: GetOptionTypesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.optionTypes) {
      OptionType.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOptionTypesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOptionTypesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.optionTypes.push(OptionType.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateOptionValueRequest(): CreateOptionValueRequest {
  return {};
}

export const CreateOptionValueRequest: MessageFns<CreateOptionValueRequest> = {
  encode(message: CreateOptionValueRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.optionTypeId !== undefined) {
      StringValue.encode({ value: message.optionTypeId! }, writer.uint32(10).fork()).join();
    }
    if (message.value !== undefined) {
      StringValue.encode({ value: message.value! }, writer.uint32(18).fork()).join();
    }
    if (message.mediaUrl !== undefined) {
      StringValue.encode({ value: message.mediaUrl! }, writer.uint32(26).fork()).join();
    }
    if (message.displayOrder !== undefined) {
      Int32Value.encode({ value: message.displayOrder! }, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateOptionValueRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOptionValueRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.optionTypeId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = StringValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.mediaUrl = StringValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.displayOrder = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateOptionValueResponse(): CreateOptionValueResponse {
  return { id: "" };
}

export const CreateOptionValueResponse: MessageFns<CreateOptionValueResponse> = {
  encode(message: CreateOptionValueResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateOptionValueResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOptionValueResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetOptionValuesRequest(): GetOptionValuesRequest {
  return {};
}

export const GetOptionValuesRequest: MessageFns<GetOptionValuesRequest> = {
  encode(message: GetOptionValuesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.optionTypeId !== undefined) {
      StringValue.encode({ value: message.optionTypeId! }, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOptionValuesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOptionValuesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.optionTypeId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetOptionValuesResponse(): GetOptionValuesResponse {
  return { optionValues: [] };
}

export const GetOptionValuesResponse: MessageFns<GetOptionValuesResponse> = {
  encode(message: GetOptionValuesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.optionValues) {
      OptionValue.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOptionValuesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOptionValuesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.optionValues.push(OptionValue.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateVariantRequest(): CreateVariantRequest {
  return { options: [] };
}

export const CreateVariantRequest: MessageFns<CreateVariantRequest> = {
  encode(message: CreateVariantRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.productId !== undefined) {
      StringValue.encode({ value: message.productId! }, writer.uint32(10).fork()).join();
    }
    if (message.sku !== undefined) {
      StringValue.encode({ value: message.sku! }, writer.uint32(18).fork()).join();
    }
    if (message.price !== undefined) {
      DoubleValue.encode({ value: message.price! }, writer.uint32(26).fork()).join();
    }
    if (message.stock !== undefined) {
      Int32Value.encode({ value: message.stock! }, writer.uint32(34).fork()).join();
    }
    if (message.mediaUrl !== undefined) {
      StringValue.encode({ value: message.mediaUrl! }, writer.uint32(42).fork()).join();
    }
    for (const v of message.options) {
      writer.uint32(50).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateVariantRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateVariantRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.productId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sku = StringValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.price = DoubleValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.stock = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.mediaUrl = StringValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.options.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateVariantResponse(): CreateVariantResponse {
  return { id: "" };
}

export const CreateVariantResponse: MessageFns<CreateVariantResponse> = {
  encode(message: CreateVariantResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateVariantResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateVariantResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseReserveStockRequest(): ReserveStockRequest {
  return { items: [] };
}

export const ReserveStockRequest: MessageFns<ReserveStockRequest> = {
  encode(message: ReserveStockRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      VariantItem.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReserveStockRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReserveStockRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.items.push(VariantItem.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseReserveStockResponse(): ReserveStockResponse {
  return { reservationId: "", variants: [] };
}

export const ReserveStockResponse: MessageFns<ReserveStockResponse> = {
  encode(message: ReserveStockResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reservationId !== "") {
      writer.uint32(10).string(message.reservationId);
    }
    for (const v of message.variants) {
      ReserveStockResponse_VariantWithProduct.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReserveStockResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReserveStockResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.reservationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.variants.push(ReserveStockResponse_VariantWithProduct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseReserveStockResponse_VariantWithProduct(): ReserveStockResponse_VariantWithProduct {
  return { id: "", sku: "", price: 0, salePrice: 0, stock: 0, mediaUrl: "", productId: "", productName: "" };
}

export const ReserveStockResponse_VariantWithProduct: MessageFns<ReserveStockResponse_VariantWithProduct> = {
  encode(message: ReserveStockResponse_VariantWithProduct, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.sku !== "") {
      writer.uint32(18).string(message.sku);
    }
    if (message.price !== 0) {
      writer.uint32(25).double(message.price);
    }
    if (message.salePrice !== 0) {
      writer.uint32(33).double(message.salePrice);
    }
    if (message.stock !== 0) {
      writer.uint32(40).int32(message.stock);
    }
    if (message.mediaUrl !== "") {
      writer.uint32(50).string(message.mediaUrl);
    }
    if (message.productId !== "") {
      writer.uint32(58).string(message.productId);
    }
    if (message.productName !== "") {
      writer.uint32(66).string(message.productName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReserveStockResponse_VariantWithProduct {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReserveStockResponse_VariantWithProduct();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sku = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.price = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.salePrice = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.stock = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.mediaUrl = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.productName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseReleaseStockRequest(): ReleaseStockRequest {
  return { reservationId: "" };
}

export const ReleaseStockRequest: MessageFns<ReleaseStockRequest> = {
  encode(message: ReleaseStockRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reservationId !== "") {
      writer.uint32(10).string(message.reservationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReleaseStockRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReleaseStockRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.reservationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseVariantItem(): VariantItem {
  return { variantId: "", quantity: 0 };
}

export const VariantItem: MessageFns<VariantItem> = {
  encode(message: VariantItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.variantId !== "") {
      writer.uint32(10).string(message.variantId);
    }
    if (message.quantity !== 0) {
      writer.uint32(16).int32(message.quantity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VariantItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVariantItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.variantId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.quantity = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseProduct(): Product {
  return {
    id: "",
    name: "",
    description: "",
    brand: "",
    minPrice: 0,
    maxPrice: 0,
    totalSaleCount: 0,
    rating: 0,
    mediaUrls: [],
  };
}

export const Product: MessageFns<Product> = {
  encode(message: Product, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.brand !== "") {
      writer.uint32(34).string(message.brand);
    }
    if (message.minPrice !== 0) {
      writer.uint32(41).double(message.minPrice);
    }
    if (message.maxPrice !== 0) {
      writer.uint32(49).double(message.maxPrice);
    }
    if (message.totalSaleCount !== 0) {
      writer.uint32(56).int32(message.totalSaleCount);
    }
    if (message.rating !== 0) {
      writer.uint32(65).double(message.rating);
    }
    for (const v of message.mediaUrls) {
      writer.uint32(74).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Product {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProduct();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.brand = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.minPrice = reader.double();
          continue;
        }
        case 6: {
          if (tag !== 49) {
            break;
          }

          message.maxPrice = reader.double();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.totalSaleCount = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 65) {
            break;
          }

          message.rating = reader.double();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.mediaUrls.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseOptionType(): OptionType {
  return { id: "", name: "", displayOrder: 0, optionValues: [] };
}

export const OptionType: MessageFns<OptionType> = {
  encode(message: OptionType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.displayOrder !== 0) {
      writer.uint32(24).int32(message.displayOrder);
    }
    for (const v of message.optionValues) {
      OptionValue.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OptionType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOptionType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.displayOrder = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.optionValues.push(OptionValue.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseOptionValue(): OptionValue {
  return { id: "", value: "", mediaUrl: "", displayOrder: 0 };
}

export const OptionValue: MessageFns<OptionValue> = {
  encode(message: OptionValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    if (message.mediaUrl !== "") {
      writer.uint32(26).string(message.mediaUrl);
    }
    if (message.displayOrder !== 0) {
      writer.uint32(32).int32(message.displayOrder);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OptionValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOptionValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.mediaUrl = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.displayOrder = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseVariant(): Variant {
  return { id: "", sku: "", price: 0, salePrice: 0, stock: 0, status: "", mediaUrl: "", selectedOptions: [] };
}

export const Variant: MessageFns<Variant> = {
  encode(message: Variant, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.sku !== "") {
      writer.uint32(18).string(message.sku);
    }
    if (message.price !== 0) {
      writer.uint32(25).double(message.price);
    }
    if (message.salePrice !== 0) {
      writer.uint32(33).double(message.salePrice);
    }
    if (message.stock !== 0) {
      writer.uint32(40).int32(message.stock);
    }
    if (message.status !== "") {
      writer.uint32(50).string(message.status);
    }
    if (message.mediaUrl !== "") {
      writer.uint32(58).string(message.mediaUrl);
    }
    for (const v of message.selectedOptions) {
      SelectedOption.encode(v!, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Variant {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVariant();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sku = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.price = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.salePrice = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.stock = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.mediaUrl = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.selectedOptions.push(SelectedOption.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseSelectedOption(): SelectedOption {
  return { optionTypeId: "", optionValueId: "" };
}

export const SelectedOption: MessageFns<SelectedOption> = {
  encode(message: SelectedOption, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.optionTypeId !== "") {
      writer.uint32(10).string(message.optionTypeId);
    }
    if (message.optionValueId !== "") {
      writer.uint32(18).string(message.optionValueId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SelectedOption {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSelectedOption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.optionTypeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.optionValueId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

/**
 * ==========================
 * Services
 * ==========================
 */

export interface ProductServiceClient {
  getProducts(request: GetProductsRequest): Observable<GetProductsResponse>;

  getProductDetail(request: GetProductDetailRequest): Observable<GetProductDetailResponse>;

  createProduct(request: CreateProductRequest): Observable<CreateProductResponse>;
}

/**
 * ==========================
 * Services
 * ==========================
 */

export interface ProductServiceController {
  getProducts(
    request: GetProductsRequest,
  ): Promise<GetProductsResponse> | Observable<GetProductsResponse> | GetProductsResponse;

  getProductDetail(
    request: GetProductDetailRequest,
  ): Promise<GetProductDetailResponse> | Observable<GetProductDetailResponse> | GetProductDetailResponse;

  createProduct(
    request: CreateProductRequest,
  ): Promise<CreateProductResponse> | Observable<CreateProductResponse> | CreateProductResponse;
}

export function ProductServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["getProducts", "getProductDetail", "createProduct"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("ProductService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("ProductService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const PRODUCT_SERVICE_NAME = "ProductService";

/**
 * ==========================
 * Services
 * ==========================
 */
export type ProductServiceService = typeof ProductServiceService;
export const ProductServiceService = {
  getProducts: {
    path: "/com.ecommerce.springboot.product.v1.ProductService/GetProducts",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetProductsRequest): Buffer => Buffer.from(GetProductsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetProductsRequest => GetProductsRequest.decode(value),
    responseSerialize: (value: GetProductsResponse): Buffer => Buffer.from(GetProductsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetProductsResponse => GetProductsResponse.decode(value),
  },
  getProductDetail: {
    path: "/com.ecommerce.springboot.product.v1.ProductService/GetProductDetail",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetProductDetailRequest): Buffer =>
      Buffer.from(GetProductDetailRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetProductDetailRequest => GetProductDetailRequest.decode(value),
    responseSerialize: (value: GetProductDetailResponse): Buffer =>
      Buffer.from(GetProductDetailResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetProductDetailResponse => GetProductDetailResponse.decode(value),
  },
  createProduct: {
    path: "/com.ecommerce.springboot.product.v1.ProductService/CreateProduct",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateProductRequest): Buffer => Buffer.from(CreateProductRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateProductRequest => CreateProductRequest.decode(value),
    responseSerialize: (value: CreateProductResponse): Buffer =>
      Buffer.from(CreateProductResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CreateProductResponse => CreateProductResponse.decode(value),
  },
} as const;

export interface ProductServiceServer extends UntypedServiceImplementation {
  getProducts: handleUnaryCall<GetProductsRequest, GetProductsResponse>;
  getProductDetail: handleUnaryCall<GetProductDetailRequest, GetProductDetailResponse>;
  createProduct: handleUnaryCall<CreateProductRequest, CreateProductResponse>;
}

export interface OptionServiceClient {
  createOptionType(request: CreateOptionTypeRequest): Observable<CreateOptionTypeResponse>;

  getOptionTypes(request: GetOptionTypesRequest): Observable<GetOptionTypesResponse>;

  createOptionValue(request: CreateOptionValueRequest): Observable<CreateOptionValueResponse>;

  getOptionValues(request: GetOptionValuesRequest): Observable<GetOptionValuesResponse>;
}

export interface OptionServiceController {
  createOptionType(
    request: CreateOptionTypeRequest,
  ): Promise<CreateOptionTypeResponse> | Observable<CreateOptionTypeResponse> | CreateOptionTypeResponse;

  getOptionTypes(
    request: GetOptionTypesRequest,
  ): Promise<GetOptionTypesResponse> | Observable<GetOptionTypesResponse> | GetOptionTypesResponse;

  createOptionValue(
    request: CreateOptionValueRequest,
  ): Promise<CreateOptionValueResponse> | Observable<CreateOptionValueResponse> | CreateOptionValueResponse;

  getOptionValues(
    request: GetOptionValuesRequest,
  ): Promise<GetOptionValuesResponse> | Observable<GetOptionValuesResponse> | GetOptionValuesResponse;
}

export function OptionServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["createOptionType", "getOptionTypes", "createOptionValue", "getOptionValues"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("OptionService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("OptionService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const OPTION_SERVICE_NAME = "OptionService";

export type OptionServiceService = typeof OptionServiceService;
export const OptionServiceService = {
  createOptionType: {
    path: "/com.ecommerce.springboot.product.v1.OptionService/CreateOptionType",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateOptionTypeRequest): Buffer =>
      Buffer.from(CreateOptionTypeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateOptionTypeRequest => CreateOptionTypeRequest.decode(value),
    responseSerialize: (value: CreateOptionTypeResponse): Buffer =>
      Buffer.from(CreateOptionTypeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CreateOptionTypeResponse => CreateOptionTypeResponse.decode(value),
  },
  getOptionTypes: {
    path: "/com.ecommerce.springboot.product.v1.OptionService/GetOptionTypes",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetOptionTypesRequest): Buffer =>
      Buffer.from(GetOptionTypesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetOptionTypesRequest => GetOptionTypesRequest.decode(value),
    responseSerialize: (value: GetOptionTypesResponse): Buffer =>
      Buffer.from(GetOptionTypesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetOptionTypesResponse => GetOptionTypesResponse.decode(value),
  },
  createOptionValue: {
    path: "/com.ecommerce.springboot.product.v1.OptionService/CreateOptionValue",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateOptionValueRequest): Buffer =>
      Buffer.from(CreateOptionValueRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateOptionValueRequest => CreateOptionValueRequest.decode(value),
    responseSerialize: (value: CreateOptionValueResponse): Buffer =>
      Buffer.from(CreateOptionValueResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CreateOptionValueResponse => CreateOptionValueResponse.decode(value),
  },
  getOptionValues: {
    path: "/com.ecommerce.springboot.product.v1.OptionService/GetOptionValues",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetOptionValuesRequest): Buffer =>
      Buffer.from(GetOptionValuesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetOptionValuesRequest => GetOptionValuesRequest.decode(value),
    responseSerialize: (value: GetOptionValuesResponse): Buffer =>
      Buffer.from(GetOptionValuesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetOptionValuesResponse => GetOptionValuesResponse.decode(value),
  },
} as const;

export interface OptionServiceServer extends UntypedServiceImplementation {
  createOptionType: handleUnaryCall<CreateOptionTypeRequest, CreateOptionTypeResponse>;
  getOptionTypes: handleUnaryCall<GetOptionTypesRequest, GetOptionTypesResponse>;
  createOptionValue: handleUnaryCall<CreateOptionValueRequest, CreateOptionValueResponse>;
  getOptionValues: handleUnaryCall<GetOptionValuesRequest, GetOptionValuesResponse>;
}

export interface VariantServiceClient {
  createVariant(request: CreateVariantRequest): Observable<CreateVariantResponse>;

  reserveStock(request: ReserveStockRequest): Observable<ReserveStockResponse>;

  releaseStock(request: ReleaseStockRequest): Observable<DoubleValue>;
}

export interface VariantServiceController {
  createVariant(
    request: CreateVariantRequest,
  ): Promise<CreateVariantResponse> | Observable<CreateVariantResponse> | CreateVariantResponse;

  reserveStock(
    request: ReserveStockRequest,
  ): Promise<ReserveStockResponse> | Observable<ReserveStockResponse> | ReserveStockResponse;

  releaseStock(request: ReleaseStockRequest): Promise<DoubleValue> | Observable<DoubleValue> | DoubleValue;
}

export function VariantServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["createVariant", "reserveStock", "releaseStock"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("VariantService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("VariantService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const VARIANT_SERVICE_NAME = "VariantService";

export type VariantServiceService = typeof VariantServiceService;
export const VariantServiceService = {
  createVariant: {
    path: "/com.ecommerce.springboot.product.v1.VariantService/CreateVariant",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateVariantRequest): Buffer => Buffer.from(CreateVariantRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateVariantRequest => CreateVariantRequest.decode(value),
    responseSerialize: (value: CreateVariantResponse): Buffer =>
      Buffer.from(CreateVariantResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CreateVariantResponse => CreateVariantResponse.decode(value),
  },
  reserveStock: {
    path: "/com.ecommerce.springboot.product.v1.VariantService/ReserveStock",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ReserveStockRequest): Buffer => Buffer.from(ReserveStockRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ReserveStockRequest => ReserveStockRequest.decode(value),
    responseSerialize: (value: ReserveStockResponse): Buffer =>
      Buffer.from(ReserveStockResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ReserveStockResponse => ReserveStockResponse.decode(value),
  },
  releaseStock: {
    path: "/com.ecommerce.springboot.product.v1.VariantService/ReleaseStock",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ReleaseStockRequest): Buffer => Buffer.from(ReleaseStockRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ReleaseStockRequest => ReleaseStockRequest.decode(value),
    responseSerialize: (value: number | undefined): Buffer =>
      Buffer.from(DoubleValue.encode({ value: value ?? 0 }).finish()),
    responseDeserialize: (value: Buffer): number | undefined => DoubleValue.decode(value).value,
  },
} as const;

export interface VariantServiceServer extends UntypedServiceImplementation {
  createVariant: handleUnaryCall<CreateVariantRequest, CreateVariantResponse>;
  reserveStock: handleUnaryCall<ReserveStockRequest, ReserveStockResponse>;
  releaseStock: handleUnaryCall<ReleaseStockRequest, number | undefined>;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
}
